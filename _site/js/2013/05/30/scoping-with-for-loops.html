<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>For Loops and Scope Issues</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/zenburn.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/bootstrap.css">
        <link rel="stylesheet" href="/css/main.css">
        <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">

        <!-- Typekit -->
        <script type="text/javascript" src="//use.typekit.net/tlc4biu.js"></script>
        <script type="text/javascript">try{Typekit.load();}catch(e){}</script>

    </head>
    <body>

      <div class="container-narrow">
        <div class="site">
          <h2>
  <a href="/" class="home"><i class="icon-home"></i></a>
  For Loops and Scope Issues
</h2>

<p class="meta">30 May 2013</p>

<div class="post">
<p>We want to explore in simple example how function scoping can be confusing for
new javascript developers and tackle a few ways in which we can work around it.
To demonstrate this, we will construct an simple use case. We have a list of
objects and we want to programatically generate a <code>toString</code> method for each of
those objects. Look closely at the code and see if you can spot the error.</p>

<div class="highlight"><pre><code class="javascript"><span class="c1">// Our test array</span>
<span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Joe&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Sally&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Jim&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Ann&#39;</span><span class="p">}</span>
<span class="p">];</span>

<span class="c1">// Method 1: Simple for loops</span>
<span class="kd">function</span> <span class="nx">forLoop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">forLoop</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">items</span><span class="p">[</span><span class="nx">x</span><span class="p">].</span><span class="nx">toString</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>If you run this code, you will get an error when you attepmt to print out
<code>items[i].name</code> in the <code>toString</code> method. Why is this? If we inspect the code
further, we find out that <code>i</code> is 4, not quite what we expected. To make this
code work, we could change the line to be:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">forLoop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>This still does not make the code work as desired, it only stops the code from
crashing.</p>

<p>Just a note on symantics, a shortcut to check if a property or method
exists is to use the <code>&amp;&amp;</code> operator. If you wanted to check if a method exists
before running it you could execute it safely via <code>someMethod &amp;&amp; someMethod()</code>.
We wrapped <code>items[i] &amp;&amp; items[i].name</code> in parens in the above code to make we
are executing the return value and not the boolean expression.</p>

<p>Back to the code sample! The reason <code>i</code> is 4 and not 0-3 is due to functional
scoping. in the <code>forLoop</code> method, the inner <code>for</code> loop does not have a scope
context and therfore inner functions do not have a stack snapshot of the
variables. This results in the <code>for</code> loop executing to completion and saving <code>i</code>
as 4. When we call the <code>toString</code> method, our scope belongs to the <code>forLoop</code>
method and not the <code>for</code> loop itself. The <code>forLoop</code> method sees <code>i</code> as 4, again,
not our desired results.</p>

<h2>Bind</h2>

<p>To overcome this, we need to ensure we are making a subscope every time we need
to access variables in a callback. Our first attempt will be to use the native
<code>bind</code> method to set the scope of the <code>toString</code> method.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">forBind</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">}.</span><span class="nx">bind</span><span class="p">({},</span> <span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>If you notice, the code looks very similar to what we had before. To emphasize
the differences, here is a clean anonymous function signature.</p>

<div class="highlight"><pre><code class="javascript"><span class="c1">// new</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* code*/</span> <span class="p">}.</span><span class="nx">bind</span><span class="p">({},</span> <span class="nx">i</span><span class="p">);</span>

<span class="c1">// old</span>
<span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* code */</span> <span class="p">}</span>
</code></pre></div>

<p>We are giving the new function a paramater and we are then using <code>bind</code> to set
the scope and initial paramaters. Now, when we call <code>forBind</code> the functions
scope is an empty object and has a paramater <code>i</code> which is equal to the desired
value.</p>

<p>All this is due to the fact that <code>bind</code> is executing imidiatly during the
execution of the <code>for</code> loop body, not during the callback. As a result, <code>i</code> is
set correctly. Behind the scenes, <code>bind</code> is taking the intial function, modifies
it, and returns a copy with a new scope and paramater list. This new function is
given to the <code>toString</code> method.</p>

<p>The question comes up, why cant we just give the paramater <code>i</code> to the origional
function like so?</p>

<div class="highlight"><pre><code class="javascript"><span class="c1">// old</span>
<span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* code */</span> <span class="p">}</span>
</code></pre></div>

<p>Digging a little deeper, all this does is accepts a value from the <em>callers</em>
scope, not from the scope of the origional <code>for</code> loop.</p>

<h2>Closures</h2>

<p>Looking back at the origional issue, we came into this mess by not having block
scope. Instead we are stuck with functional scope, so to solve it we could make
a new function to house our scope, this method is called using closures.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">forClosure</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">toString</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}(</span><span class="nx">i</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Alot is going on here, here is the isolated anonymous function signature.</p>

<div class="highlight"><pre><code class="javascript"><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">}(</span><span class="nx">i</span><span class="p">))</span>
</code></pre></div>

<p>What in the world is this doing? Again, lets build up from scratch. In
javascript, we can make functions without names (which are called anonymous)
with the syntax:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
</code></pre></div>

<p>The two most common use cases for these anonymous functions are for variable
assignment and durring method callbacks</p>

<div class="highlight"><pre><code class="javascript"><span class="c1">// variable assignment</span>
<span class="kd">var</span> <span class="nx">someVariable</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>

<span class="c1">// method callbacks</span>
<span class="nx">someArray</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{});</span>
</code></pre></div>

<p>Once we have created this anonymous function, it sits there until it is called.
Typically we call these functions by their name or by calling the <code>var</code> which
the function was assigned to. In some cases, we want these functions to be
executed imidiatly uppon creation, to accomplis this, we have the following
syntax.</p>

<div class="highlight"><pre><code class="javascript"><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{})()</span>
</code></pre></div>

<p>We take the function, wrap it in parens, and then append another set of parens
at the end. This ending parens set is the paramaters to the inner function. For
example...</p>

<div class="highlight"><pre><code class="javascript"><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// name == &#39;Joe&#39;</span>
    <span class="c1">// age == 10</span>
<span class="p">})(</span><span class="s1">&#39;Joe&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div>

<p>Once the compiler hits goes over this function, it is imidiatly executed with
the given paramaters. Looking back at our origionl <code>forClosure</code> method we see
that we have the inner function accept one paramater <code>i</code> and we imidiatly
execute the function with the current value of <code>i</code>.</p>

<div class="highlight"><pre><code class="javascript"><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">}(</span><span class="nx">i</span><span class="p">))</span>
</code></pre></div>

<p>Cool, but why is there that <code>return</code> statment inside of the function body? Our
origional goal was to assign <code>toSring</code> to a function which we can call later to
print out the name of the object. Since the function we provide to <code>toString</code>
gets executed imidiatly, the return value of the function gets assigned to the
<code>toString</code> property. Javascript functions automatically returned <code>undefined</code> if
no return value is explicitly given. To properly set <code>toString</code> to be a
function, we have to <em>return</em> a function. Again, since the inner function has
access to the paramaters of the outer function, we now have a safe reference to
<code>i</code>.</p>

<h2>Native Functions</h2>

<p>This is all terribly inconvenient, are we expected to use closures or bind every
time we want to use callbacks? The short answer is no, we just need to addapt to
a more functional style of coding over imperative coding.</p>

<p>Instead of using <code>for</code> loops which are imparative we can use the native
<code>forEach</code> function that javascript arrays have access to.</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">forEachLoop</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">item</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

<p>Now, we rely on the javascript interpereter to properly call this function for
each of the items on the list. Since this is a function, we can safely rely on
the scope to stay as we expect it to be. Much simpler than the previous two
methods.</p>

<h2>Wrap Up</h2>

<p>After looking through all of this, you may ask yourself why would you ever not
use the functional syntax?</p>

<p>One reason is performance. Every time the <code>forEach</code> method is called, the
interperter has to do additional work setting up the stack to house our local
variables. With the simple <code>for</code> loop, this is not needed and as a result will
run faster. Some other reasons include code style preference. Some argue that it is much
easier to read and comprehend the syntax of native <code>for</code> loops.</p>

</div>


<div class="header">
  <h1 class="title"><a href="/">KawDev</a></h1>
</div>




        </div>
      </div>

    </body>
</html>
